################################################################################
# Copyright (c) 2017                                                           #
# Intwine Connect, LLC.                                                        #
#                                                                              #
# BSD-2-Clause                                                                 #
# DESCRIPTION OF OTHER RIGHTS AND LIMITATIONS                                  #
# Redistribution and use in source and binary forms, with or without           #
# modification, are permitted provided that the following conditions are met:  #
# 1. Redistributions of source code must retain the above copyright notice,    #
#    this list of conditions and the following disclaimer.                     #
# 2. Redistributions in binary form must reproduce the above copyright notice, #
#    this list of conditions and the following disclaimer in the documentation #
#    and/or other materials provided with the distribution.                    #
#                                                                              #
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" #
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,        #
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR       #
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR            #
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,        #
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,          #
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  #
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,     #
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR      #
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF       #
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                   #
################################################################################

import urllib
import sys

# Workaround for Python 2 vs 3
if sys.version_info[0] == 2:
    import urllib2

import json
import datetime as dt
from base64 import b64encode

#CBUS_IP = "cbws.intwineconnect.com:8080"
CBUS_IP = '52.11.142.255:8080'

# OAuth2 client information
GET_TOKEN = "/cloudbus/oauth/token"
clientId = ""
apiKey = ""

def get_oauth_token():
    data = clientId + ':' + apiKey

    # Handle differently for Python3
    if sys.version_info[0] == 3:
        data_bytes = data.encode("utf-8")
        creds = b64encode(data_bytes)
        creds = creds.decode("utf-8")
        url = "http://" + CBUS_IP + GET_TOKEN
        headers = {'Authorization': 'Basic ' + creds}
        body = urllib.parse.urlencode({'grant_type': 'client_credentials'})
    else:
        creds = b64encode(data)
        url = "http://" + CBUS_IP + GET_TOKEN
        headers = {'Authorization': 'Basic ' + creds}
        body = urllib.urlencode({'grant_type': 'client_credentials'})

    response = get_response(url, data=body, headers=headers)

    if 'access_token' in response:
        return response
    else:
        return None

def get_response(uri, data=None, headers=None):
    # Python 3 uses a different process to get the response
    if sys.version_info[0] == 3:
        req = urllib.request.Request(uri, headers=headers)
        if data:
            data_bytes = data.encode("utf-8")
            req.data = data_bytes
        # req = urllib.request.Request(uri, data=data, headers=headers)
        with urllib.request.urlopen(req) as read_url:
            s = read_url.read()
        response = s.decode('utf-8')
    else:
        req = urllib2.Request(uri, headers=headers)
        if data: req.add_data(data)
        read_url = urllib2.urlopen(req)
        response = ""
        for line in read_url:
            response += line
        read_url.close()
    return json.loads(response)


class cbDevice():
    """CloudBUS Device Class

    The cbDevice class enables users to interrogate the Intwine CloudBUS IoT server
    for current and historical data generated by a specific device. Each device is
    assigned a unique identifier known as a GUID.  The GUID can be assigned to the
    cbDevice instance either in the constructor or by using the setGUID method.
    """

    guid = None
    data = {}
    oauth_header = None

    def __init__(self, guid=None):
        if guid is not None:
            self.guid = guid
        token = get_oauth_token()
        if token:
            self.oauth_header = {'Authorization': 'Bearer ' + token['access_token']}

    def setGUID(self, guid):
        """Assigns the cbDevice a specified guid

        Args:
            guid: the string representation of the device identifier
        """

        assert guid, "GUID can not be empty"
        self.__init__(guid)

    def getData(self, variable, tstart=None, tend=None):
        """Get data from the CloudBUS device APIs

        Request all reported values of data sent to CloudBUS from this specific
        device with attribute = variable.  If desired, the time range over which
        the data was collected can be specified.

        Args:
            variable: name of the attribute for which to get historical data
            tstart:   optional datetime of the earliest time for which to request
                the specified attribute. Defaults to Unix time of 0.
            tend:     optional datetime of the most recent time for which to request
                the specified attribute. Defaults to tomorrow.

        Returns:
            A tuple of lists. Element 0 of the tuple is a list of datetimes
            (naive but in local time) and element 1 is the list of attibute
            values at each of the element 0 datetime points. The two lists will
            always be the same length. The lists are sorted so that element 0 of
            the time list is the earliest reported timestamp.
        """
        if not self.guid:
            raise Exception('GUID not defined')

        if tstart is None:
            tstart = dt.datetime.fromtimestamp(0)
        if tend is None:
            tend = dt.datetime.now() + dt.timedelta(days=1)  # tomorrow

        # build the CloudBUS URI
        url = 'http://' + CBUS_IP + '/cloudbus/device/'
        query = '/data?attr=%s' % variable
        query += '&start=' + tstart.strftime("%Y-%m-%d %H:%M:%S")
        query += '&end=' + tend.strftime("%Y-%m-%d %H:%M:%S")
        query = query.replace(' ', '%20')

        # request the URL and read the response
        resp = get_response(url + self.guid + query, headers=self.oauth_header)

        # format the data to be returned
        data = dict(resp['data'])
        a = sorted(data.items())
        t_vector = []
        y_vector = []
        for i in a:
            # note that the timestamp is converted to the platforms local date
            # and time, and the returned datetime object is naive.
            t_vector.append( dt.datetime.fromtimestamp(float(i[0])/1000.0) )
            y_vector.append( float(i[1]) )
        return t_vector, y_vector

    def getCurrentData(self):
        """Gets most recently reported data from the device.

        This method will return the most recently reported values for all attributes
        associated with the device.

        Returns:
            A dictionary with keys of attribute names. The value associated with
            each key is a tuple of datetime and attribute value.
            Note that the attribute value will be a string since we have no way
            to know the correct data type and things that pass isfloat( ) are
            inconsistent at best.  See https://stackoverflow.com/questions/379906/parse-string-to-float-or-int
        """
        if not self.guid:
            raise Exception('GUID not defined')

        # build the CloudBUS URI
        url = 'http://' + CBUS_IP + '/cloudbus/device/'
        query = '/currentdata'
        # request the URL and read the response
        resp = get_response(url + self.guid + query, headers=self.oauth_header)

        # format the data to be returned
        current_data = {}
        if 'endpoints' not in resp:
            raise ValueError("'endpoints' not in response")

        for endpoint in resp['endpoints']:
            for k,v in endpoint.iteritems():
                if '_time' in k or k == 'endpointId':
                    continue
                t = dt.datetime.fromtimestamp(float(endpoint[k + '_time'])/1000.0)
                current_data[k] = (t, v)

        return current_data

    def getDeviceInfo(self):
        """Get information about the device

        Request information about the physical device and its reported capabilities.

        Returns:
            A dictionary with all known information about the device.
        """
        if not self.guid:
            raise Exception('GUID not defined')

        # build the CloudBUS URI
        url = 'http://' + CBUS_IP + '/cloudbus/device/'
        # request the URL and read the response
        return get_response(url + self.guid, headers=self.oauth_header)

class cbGateway(cbDevice):
    """CloudBUS Gateway device
    """

    def getDevices(self):
        """Gets a list of devices that are provisioned to this gateway device.

        This method will return a dictionary with the GUID of all devices that
        have been provisioned to this gateway.

        Returns:
            A dictionary of provisioned devices. Each key is a different device's
            GUID and the associated value is the device type.
        """
        if not self.guid:
            raise Exception('GUID not defined')

        # build the CloudBUS URI
        url = 'http://' + CBUS_IP + '/cloudbus/gateway/'
        # request the URL and read the response
        resp = get_response(url + self.guid, headers=self.oauth_header)

        # format the data to be returned
        devices = {}
        if 'devices' not in resp:
            return None

        for device in resp['devices']:
            devices[device['deviceId']] = device['deviceType']

        return devices

    def getCurrentData(self):
        """Gets most recently reported data from the gateway.

        This method will return the most recently reported values for all attributes
        associated with the gateway.

        Returns:
            A dictionary with keys of attribute names. The value associated with
            each key is a tuple of datetime and attribute value.
            Note that the attribute value will be a string since we have no way
            to know the correct data type and things that pass isfloat( ) are
            inconsistent at best.  See https://stackoverflow.com/questions/379906/parse-string-to-float-or-int
        """
        if not self.guid:
            raise Exception('GUID not defined')

        # build the CloudBUS URI
        url = 'http://' + CBUS_IP + '/cloudbus/device/'
        query = '/currentdata'
        # request the URL and read the response
        resp = get_response(url + self.guid + query, headers=self.oauth_header)

        # format the data to be returned
        current_data = {}
        if 'currentData' not in resp:
            raise ValueError("'currentData' not in response")

        for k,v in resp['currentData'].iteritems():
            if '_time' in k or k == 'device_id':
                continue
            t = dt.datetime.fromtimestamp(float(resp['currentData'][k + '_time'])/1000.0)
            current_data[k] = (t, v)

        return current_data
